/// # Althread Grammar
/// This file defines the grammar for the Althread programming language,

program = _{ SOI ~ blocks* ~ EOI }

/// Directives
private_directive = { "@" ~ PRIVATE_KW }

/// ## Program Structure
/// The main building blocks of an Althread program are:
/// - **Main Block**: The entry point of the program.
/// - **Shared Block**: Declares global variables accessible across different parts of the program.
/// - **Condition Block**: Monitors conditions at each atomic step (e.g., always, never, eventually).
/// - **Program Block**: Encapsulates code that runs concurrently in parallel processes.
/// - **Function Block**: User-defined functions
blocks = _{ import_block | main_block | global_block | condition_block | ltl_condition_block | program_block | function_block }

global_block    = { GLOBAL_KW ~ code_block }
condition_block = { condition_keywords ~ expression_block }
ltl_condition_block = { LTL_KW ~ ltl_block }
program_block   = { private_directive? ~ PROGRAM_KW ~ identifier ~ arg_list ~ code_block }
main_block      = { private_directive? ~ MAIN_KW ~ code_block }

code_block           = { "{" ~ statement* ~ "}" }
expression_block     = { "{" ~ expression_statement* ~ "}" }
expression_statement = { expression ~ ";" }

condition_keywords = _{ ALWAYS_KW | NEVER_KW | EVENTUALLY_KW }

ltl_block = { "{" ~ ltl_expression_statement* ~ "}"}
ltl_expression_statement = { ltl_expression ~ ";" }

/// ## Statements
/// Statements are the executable instructions in the language.
/// They include assignments, declarations, expressions, print statements,
/// function calls, and control flow structures.

statement = {
    assignment_statement
  | declaration_statement
  | channel_declaration_statement
  | run_statement
  | send_statement
  | wait_statement
  | atomic_statement
  | if_control
  | for_control
  | loop_control
  | while_control
  | call_statement
  | code_block
  | break_loop_statement
  | return_statement
}


break_loop_statement = { (BREAK_KW | CONTINUE_KW) ~ identifier? ~ ";" }
assignment_statement  = _{ assignment ~ ";" }
declaration_statement = _{ declaration ~ ";" }
wait_statement        =  { WAIT_KW ~ (
      waiting_block 
    | waiting_block_case) }
atomic_statement        =  { (ATOMIC_KW | "!") ~ statement }
call_statement        = _{ fn_call ~ ";" }
run_statement         = _{ run_call ~ ";" }
send_statement         = _{ send_call ~ ";" }
channel_declaration_statement = _{ channel_declaration ~ ";" }

// Functions
function_block = { private_directive? ~ FN_KW ~ identifier ~ arg_list ~ RARROW ~ datatype ~ code_block }
return_statement = { RETURN_KW ~ expression? ~ ";" }


// Import block definition
import_block = { IMPORT_KW ~ "[" ~ import_list? ~ "]" }
import_list = { import_item ~ ("," ~ import_item)* ~ ","? }
import_item = { import_path ~ (AS_KW ~ identifier)? }
import_path = { import_segment ~ ("/" ~ import_segment)* }
import_segment = { domain_identifier | identifier }
domain_identifier = @{ ASCII_ALPHA ~ domain_char* }
domain_char = _{ ASCII_ALPHANUMERIC | "_" | "." | "-" }


fn_call  = { object_identifier ~ tuple_expression }
run_call = { RUN_KW ~ object_identifier ~ tuple_expression }
send_call = { SEND_KW ~ object_identifier ~ tuple_expression }
channel_declaration = { 
    CHANNEL_KW ~ 
    object_identifier ~ 
    "<"? ~
    type_list ~ 
    ">"? ~
    object_identifier }

type_list = { "(" ~ datatype ~ ("," ~ datatype)* ~ ")" }
pattern_list = { "(" ~ pattern ~ ("," ~ pattern)* ~ ")" }
arg_list = { 
  ( "(" ~ ")")
  | ("(" ~ (identifier ~ ":" ~ datatype) ~ ("," ~ identifier ~ ":" ~ datatype)* ~ ")" )
}
pattern = { identifier | literal }

/// ### Assignments
/// Assignments assign values to variables.
/// - **Unary Assignments**: Increment or decrement a variable (e.g., a++).
/// - **Binary Assignments**: Assign the result of an expression to a variable (e.g., a = b + c).
assignment = { binary_assignment }

side_effect_expression    = { run_call | fn_call | expression |  bracket_expression }

bracket_expression = { "[" ~ (range_expression | list_literal_inner) ~ "]" }

list_literal_inner = { (side_effect_expression ~ ("," ~ side_effect_expression)*)? }

binary_assignment          = { 
    object_identifier ~ 
    binary_assignment_operator ~ 
    side_effect_expression }
binary_assignment_operator = { ASSIGN_OP | ADD_ASSIGN_OP | SUB_ASSIGN_OP | MUL_ASSIGN_OP | DIV_ASSIGN_OP | MOD_ASSIGN_OP }

/// ### Declarations
/// Declarations introduce new variables, which can be mutable (let) or immutable (const).
declaration         = { declaration_keyword ~ identifier ~ (":" ~ datatype)? ~ ("=" ~ side_effect_expression)? }
declaration_keyword = { LET_KW | CONST_KW }


receive_expression = { RECEIVE_KW ~ object_identifier? ~ pattern_list ~ ("=>" ~ statement)? }

/// ### Expressions
/// Expressions evaluate values based on arithmetic and logical operations, following standard precedence rules.
expression = { binary_expression }

tuple_expression = {
 ("(" ~ ")") | ("(" ~ expression ~ ("," ~ expression)* ~ ")")
}
range_expression = {
	(expression ~ LIST_OP ~ expression)
}

primary_expression = _{ fn_call | literal | object_identifier | "(" ~ expression ~ ")" }

unary_expression = _{ unary_operator? ~ primary_expression }
unary_operator   =  { POS_OP | NEG_OP | NOT_OP }

binary_expression   = _{ unary_expression ~ (binary_operator ~ unary_expression)* }
binary_operator     = _{ or_operator | and_operator | equality_operator | comparison_operator | term_operator | factor_operator }
or_operator         =  { OR_OP }
and_operator        =  { AND_OP }
equality_operator   =  { EQ_OP | NE_OP }
comparison_operator =  { LE_OP | GE_OP | LT_OP | GT_OP }
term_operator       =  { ADD_OP | SUB_OP }
factor_operator     =  { MUL_OP | DIV_OP | MOD_OP }

waiting_block = {
    (SEQ_KW | FIRST_KW) ~ "{" ~ waiting_block_case* ~ "}"
}
waiting_block_case       = { 
   (receive_expression | expression)
   ~ (";" | ("=>" ~ statement)) }

/// ### Control Flow
/// Control flow structures include conditional execution and loops.

if_control    = { IF_KW ~ expression ~ code_block ~ (ELSE_KW ~ (if_control | code_block))? }
while_control = { WHILE_KW ~ expression ~ code_block }
loop_control = { LOOP_KW ~ statement }
for_control = { FOR_KW ~ identifier ~ "in" ~ list_expression ~ statement }

list_expression = _{ (range_expression | expression) }

/// ### LTL Expressions
ltl_expression = { ltl_binary_expression }

ltl_primary = _{ ltl_operand | "(" ~ ltl_expression ~ ")" }
ltl_operand = { BOOL | object_identifier | "(" ~ expression ~ ")" }

ltl_unary_expression = _{ ltl_unary_operator* ~ ltl_primary }
ltl_unary_operator = { NOT_OP | ltl_always_operator | ltl_eventually_operator }

ltl_always_operator = { LTL_ALWAYS_OP | ALWAYS_KW }
ltl_eventually_operator = { LTL_EVENTUALLY_OP | EVENTUALLY_KW}
LTL_ALWAYS_OP = { "[]" }
LTL_EVENTUALLY_OP = { "<>" }

ltl_binary_expression = _{ ltl_unary_expression ~ (ltl_binary_operator ~ ltl_unary_expression)*}
ltl_binary_operator = _{ ltl_temporal_op | ltl_logical_op }
ltl_temporal_op = _{ ltl_until | ltl_weak_until | ltl_release }
ltl_logical_op = _{ and_operator | or_operator | ltl_implies | ltl_equivalent }

ltl_until = { LTL_UNTIL_OP | LTL_UNTIL_KW }
ltl_weak_until = { LTL_WEAK_UNTIL_OP | LTL_WEAK_UNTIL_KW }
LTL_WEAK_UNTIL_KW = {(LTL_WEAK_KW ~ LTL_UNTIL_KW)}
ltl_release = { LTL_RELEASE_OP | LTL_RELEASE_KW }

ltl_implies = { LTL_IMPLIES_OP | LTL_IMPLIES_KW }
ltl_equivalent = { LTL_EQUIVALENT_OP | LTL_EQUIVALENT_KW }

LTL_UNTIL_OP = { "U" }
LTL_WEAK_UNTIL_OP = { "W" }
LTL_RELEASE_OP  = { "V" }
LTL_IMPLIES_OP = { "=>" }
LTL_EQUIVALENT_OP = { "<=>" }

/// ## Tokens
/// This section defines the keywords, operators, datatypes, and other tokens used in Althread.

/// ### Keywords
/// Keywords define the core constructs of the language.
KEYWORDS = _{
    MAIN_KW
  | GLOBAL_KW
  | PROGRAM_KW
  | ALWAYS_KW
  | EVENTUALLY_KW
  | NEVER_KW
  | LTL_KW
  | LTL_UNTIL_KW
  | LTL_WEAK_KW
  | LTL_RELEASE_KW
  | LTL_IMPLIES_KW
  | LTL_EQUIVALENT_KW
  | RUN_KW
  | LET_KW
  | CONST_KW
  | IF_KW
  | ELSE_KW
  | WHILE_KW
  | FN_KW
  | RETURN_KW
  | IMPORT_KW
  | AS_KW
  | PRIVATE_KW
  | BOOL
  | INT_TYPE
  | FLOAT_TYPE
  | STR_TYPE
  | VOID_TYPE
}

MAIN_KW    = _{ "main" }
GLOBAL_KW  = _{ "shared" }
PROGRAM_KW = _{ "program" }
WAIT_KW    = _{ "await" }
ALWAYS_KW  =  { "always" }
EVENTUALLY_KW  =  { "eventually" }
NEVER_KW   =  { "never" }
LTL_KW     =  { "ltl" }
LTL_UNTIL_KW = { "until" }
LTL_WEAK_KW = { "weak" }
LTL_RELEASE_KW = { "release" }
LTL_IMPLIES_KW = { "implies" }
LTL_EQUIVALENT_KW = { "equals" }

RUN_KW     = _{ "run" }

FIRST_KW = { "first" }
SEQ_KW   = { "seq" }

LET_KW   = { "let" }
CONST_KW = { "const" }

IF_KW    = _{ "if" }
ELSE_KW  = _{ "else" }
WHILE_KW = _{ "while" }
FOR_KW = _{ "for" }
LOOP_KW = _{ "loop" }
BREAK_KW = { "break" }
CONTINUE_KW = { "continue" }

SEND_KW = _{ "send" }
RECEIVE_KW = _{ "receive" }
CHANNEL_KW = _{ "channel" }

TRUE_KW  = _{ "true" }
FALSE_KW = _{ "false" }
NULL_KW  = _{ "null" }

ATOMIC_KW = _{ "atomic" }

PRIVATE_KW = _{ "private" }

// Functions
FN_KW = _{ "fn" }
RETURN_KW = _{ "return" }
RARROW = { "->" }

IMPORT_KW = _{ "import" }
AS_KW = _{ "as" }

/// ### Operators
/// Operators are used for arithmetic, logical operations, and assignments.
POS_OP = { "+" }
NEG_OP = { "-" }
NOT_OP = { "!" }

ADD_OP = { "+" }
SUB_OP = { "-" }
MUL_OP = { "*" }
DIV_OP = { "/" }
MOD_OP = { "%" }

EQ_OP  = { "==" }
NE_OP  = { "!=" }
LT_OP  = { "<" }
GT_OP  = { ">" }
LE_OP  = { "<=" }
GE_OP  = { ">=" }
AND_OP = { "&&" }
OR_OP  = { "||" }

LIST_OP = _{ ".." }

ASSIGN_OP     = { "=" }
ADD_ASSIGN_OP = { "+=" }
SUB_ASSIGN_OP = { "-=" }
MUL_ASSIGN_OP = { "*=" }
DIV_ASSIGN_OP = { "/=" }
MOD_ASSIGN_OP = { "%=" }
OR_ASSIGN_OP  = { "|=" }

/// ### Datatypes
/// Datatypes supported in Althread include boolean, integer, float, string, and void.
datatype   = { BOOL_TYPE | INT_TYPE | FLOAT_TYPE | STR_TYPE | VOID_TYPE | LIST_TYPE | PROCESS_TYPE }
BOOL_TYPE  = { "bool" }
INT_TYPE   = { "int" }
FLOAT_TYPE = { "float" }
STR_TYPE   = { "string" }
VOID_TYPE  = { "void" }
PROCESS_TYPE = { "proc" ~ "(" ~ object_identifier ~ ")" }
LIST_TYPE  = { "list" ~ "(" ~ datatype ~ ")" }

/// ### Literals
/// Include literals such as booleans, integers, floats, strings, and null.
literal =  { BOOL | FLOAT | INT | STR | NULL }
BOOL    = @{ TRUE_KW | FALSE_KW }
INT     = @{ ASCII_DIGIT+ }
FLOAT   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
STR     = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
NULL    = @{ NULL_KW }

/// ### Identifiers
/// Identifiers are used for naming variables, functions, and other constructs.
identifier        = { IDENT }
object_identifier = { IDENT ~ ("." ~ IDENT)* }

reserved_keywords = { (KEYWORDS | datatype) ~ !IDENT_CHAR }

IDENT      = @{ !reserved_keywords ~ ASCII_ALPHA ~ IDENT_CHAR* }
IDENT_CHAR = _{ ASCII_ALPHANUMERIC | "_" }

/// ## Whitespace and Comments
/// Whitespace and comments are ignored by the parser.
WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE    = _{ "\n" | "\r" | "\r\n" }

COMMENT        = _{ INLINE_COMMENT | BLOCK_COMMENT }
INLINE_COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* }
BLOCK_COMMENT  = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
